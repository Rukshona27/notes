<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        html{
            hyphens: auto;
        }
        .container{
            display: flex;
            height: auto;
        }
        .block_one{
            width: 800px;
        }
        .block_two{
            width: 600px;
            height: auto;
        }
        .all{
            color: rgb(9, 0, 255);
            margin-left: 20px;
            padding-top: 10px;
        }
        .alltwo{
            color: rgb(209, 237, 27);
            padding-top: 7px;
        }
        .text{
            color: white;
        }
        body{
            background-color: black;
        }
        .container{
            display: flex;
        }
        summary{
            padding-top: 5px;
        }
        aside{
            color: white;
        }
        ul li{
            padding-top:6px ;
        }
    </style>
</head>
<body>
    <h1 class="text">Язык гипертекстовой разметки HTML</h1>
    <h1 class="text">Каскадный таблицы стилей CSS</h1>
    <h2 class="text">HTML - это ключ, с помощью которого браузер отображает <em> структуру </em> страницы</h2>
    <h2 class="text">CSS - это ключ, с помощью которого браузер отображает <em> дизайн </em> страницы</h2>
    <div class="container">
        <section class="block_one">
            <details class="chapter1-3 all">
                <summary>CHAPTER 1-3</summary>
                <details>
                    <summary class="alltwo">Теги</summary>
                    <h4>Элемент:</h4>
                    <ul>
                        <li> "a" - для создания гипертекстовых 
                        ссылок на другую страницу. <br> 
                        Содержимое элемента "a" можно активизировать щелчком кнопкой мыши на веб-странице.</li>
                        <li>blockquote - цитирование "новая строка"; </li>
                        <li>q - цитирование "внутри эелемента";</li>
                        <li>"ol" (li - элемент списка) упорядоченный список;</li>
                        <li>"ul" (li - элемент списка) неупорядоченный список;</li>
                        <li>"dl" включает в себя "dt" and "dd";</li>
                        <li>"dt" - идет как заголовок;</li>
                        <li>"dd" - идет как текст с большим отступом;</li>
                        <li>code - для отображения кода из компьютерной программы;</li>
                        <li>pre - для отформатированного текста, когда хотите, чтобы браузер отобразил его именно</li>
                        <li>strong -  особым образом выделить текст.</li>
                        <li>специальный тег span - сам по себе он абсолютно ничего не делает, но для него можно применить CSS стили, которые позволят нам добавить нужный эффект к кусочку текста</li>
                    </ul>
                </details>
                <details>
                    <summary class="alltwo">Атрибуты</summary>
                    <h4>Открывающие теги могут иметь атрибуты.</h4>
                    <ul>
                        <li>type -  указывает на то, какой язык стиля мы используем;</li>
                        <li>scr - определяет имя файла с изображением, которое задается в теге img;</li>
                        <li>href (гипертекстовая ссылка) - указывает браузеру адрес назначения ссылки;</li>
                        <li> title — это  текстовое описание страницы, на которую вы ссылаетесь.</li>
                        <li>alt просто нужен небольшой кусок текста с описанием изображения.</li>
                        <li>пара атрибутов: width и height</li>
                    </ul>
                    <p>Используйте элемент "a" для создания гипертекстовых 
                    ссылок на другую страницу. <br> Содержимое элемента "a" можно активизировать щелчком 
                    кнопкой мыши на веб-странице.</p>
                </details>
                <details>
                    <summary class="alltwo">Веб-серверы/Пути</summary>
                    <section id="webServers/Ways">
                        <p>Веб-серверы обслуживают и хранят веб-страницы, которые созданы с помощью HTML и CSS. <br> 
                            Браузеры извлекают страницы и визуализируют их содержимое, основанное на HTML и CSS</p>
                        <p id="safetyRegulations"> Атрибуты всегда пишутся одинаково: сначала идет имя атрибута, затем знак равенства, <br>
                             затем значение атрибута, взятое в двойные кавычки.</p>
                        <p>Относительный путь — это ссылка, указывающая на другие страницы вашего сайта относительно веб-страницы, <br>
                            на  которой эта ссылка находится, <br>
                            точно так же как на карте место назначения имеет связь со стартовой точкой.</p>
                        <p>Используйте символы «..», чтобы сослаться на файл, который находится  в родительской папке (по отношению к папке, <br>
                            где находится файл, с которого  вы ссылаетесь)</p>
                        <p>Не  забывайте разделять части пути символом «/» (прямой слеш).</p>
                        <p>Блочные элементы отображаются отдельно, а строчные внутри основного текста страницы.</p>
                        <p>Элементы, изначально не имеющие HTML-содержимого, называются  элементами без содержимого. <br>
                            Если вам нужно использовать элемент  без содержимого, например "br" или "img", то просто указывайте 
                            открывающий тег. <br>
                            Это удобная краткая форма, уменьшающая количество кода в вашем HTML-документе.</p>
                        <p>Специальные символы - ссылка на символи  для символа ">" аббревиатура "&gt", а для символа "<" — "&lt"</p>
                        </section>
                </details>
                <details>
                    <summary class="alltwo">Справочники</summary>
                    <section id="referenceBook">
                        <h3>Ccылки/Справочники</h3>
                            <ul>
                                <li>Справочник: HTML & XHTML: The Definitive Guide (O’Reilly)</li>
                                <li>Ссылки на основные специальные символы можно посмотреть здесь:
                                http://www.w3schools.com/tags/ref_entities.asp. </li>
                                <li>Более полный их список вы найдете здесь:
                                http://www.unicode.org/charts/.</li>
                                <li> O’Reilly’s CSS Pocket Reference.</li>
                            </ul>
                        </section>
                </details>
            </details>
            <details class="chapter4 all">
                <summary>CHAPTER 4</summary>
                <details>
                    <summary class="alltwo" >Советы по выбору хостинговой компании</summary>
                    <h2 id="adviceForChoiceHosting">Советы по выбору хостинговой компании</h2>
                    <ul>
                        <li>Техническая поддержка: имеет ли хостинговая  компания хорошую систему по обработке возникающих у вас технических вопросов? <br> В лучших  компаниях на ваши вопросы ответят быстро по телефону либо по электронной почте.</li>
                        <li>Передача данных: 
                        существует ограниченное количество страниц и данных, которое хостинговая  компания позволит вам отправлять вашим посетителям в течение месяца. <br>
                        Большинство компаний в своих основных  планах предлагают приемлемое количество передаваемых данных для небольших сайтов. <br> Если же вы создаете сайт, у которого, как предполагается, будет много посетителей, то вам нужно обратить на это особое  внимание.</li>
                        <li> Резервные копии: 
                        регулярно ли хостинговая компания делает резервные копии ваших страниц и данных,  которые можно будет восстановить, если на сервере произойдет аппаратный сбой?</li>
                        <li>Доменные имена: учитывает ли хостинговая  компания имя домена при ценообразовании?</li>
                        <li>Надежность: 
                         большинство хостинговых компаний заявляют, что они осуществляют поддержку  сайтов до 99 % общего времени и более.</li>
                        <li>Дополнительные возможности: 
                        входят ли  в  ваш пакет какие-нибудь дополнительные  возможности, такие как адреса электронной почты, форумы или поддержка сценарных языков (что-то, что в будущем может вам пригодиться)?</li>
                    </ul>
                    <h5>Доменное имя - name.come</h5>
                    <h5>Имя сайта - www.name.come</h5>
                    <p>Доменные имена контролируются централизованным учреждением (называемым ICAAN).</p>
                </details>
                <details>
                    <summary class="alltwo">FTP</summary>
                    <P id="ftp">FTP -протокол передачи файлов </P>
                    <h3> FTP - команды:</h3>
                    <ul>
                        <li> dir: выводит содержимое текущего каталога.</li>
                        <li>cd: изменяет текущий каталог.<br>
                        Здесь символы «..» также обозначают переход вверх на один каталог.</li>
                        <li>pwd: 
                        показывает, в какой директории вы сейчас находитесь.</li>
                        <li>put <имя_файла>: пересылает указанный файл на сервер.</li>
                        <li>get <имя_файла>: извлекает указанный файл из сервера назад на ваш компьютер.</li>
                    </ul>
                    <p>SFTP, или Secure File Transfer Protocol (протокол безопасной пересылки данных), —  
                    это более безопасная версия FTP, <br> которая работает примерно так же. <br>
                    Только перед  приобретением SFTP убедитесь, что выбранный FTP-клиент также поддерживает егo</p>
                    <h3>Список наиболее популярных FTP-клиентов для Mac и Windows.</h3>
                    <ul>
                        <p>Для Mac OS X:</p>
                        <li>Fetch (http://fetchsoftworks.com/) — один из наиболее 
                        популярных FTP-клиентов для Mac. $</li>
                        <li>Transmit (http://www.panic.com/transmit/) $</li>
                        <li>Cyberduck (http://cyberduck.ch/) FREE</li>
                        <p>Для Windows:</p>
                        <li>Smart FTP (http://www.smartftp.com/download/) $</li>
                        <li> WS_FTP (http://www.ipswitch.com/products/fi le-transfer.asp). 
                         <br>Основная версия БЕСПЛАТНАЯ, $ для профессиональной 
                        версии</li>
                        <li>Cyberduck (http://www.cyberduck.ch). БЕСПЛАТНO</li>
                    </ul>
                </details>
                <details>
                    <summary class="alltwo">URL-адреса</summary>
                    <h5 id="url">Унифицированный  указатель ресурса  (URL) — это сетевой адрес, <br>
                        который может  быть использован для  размещения в Сети  какой-либо информации, <br> 
                        включая HTMLстраницы, аудио, видео  и многие другие формы  веб-содержимого.</h5>
                    <p> Кроме того, для  точного определения  месторасположения  ресурса URL включает  протокол, <br>
                         который нужно  использовать, чтобы  найти этот ресурс.
                    </p>
                    <h5>HTTP - протокол передачи гипертекстовых файлов</h5>
                    <p>Абсолютный путь — это то, что нужно серверу для определения местоположения требуемого файла.</p>
                    <p>Абсолютный путь — это путь от корневой папки к файлу.</p>
                    <h5>Oтносительные пути, чтобы сослаться на собственные страницы на этом же сайте, и URL-адреса, <br> чтобы создать ссылку на страницы с других сайтов.</h5>
                    <P id="target">Атрибут target говорит браузеру, где открыть веб-страницу, которая указана 
                        в атрибуте href этой ссылки. <br>Если атрибута target нет, то браузер открывает 
                        страницу в текущем окне. <br>Если в качестве значения атрибута target используется 
                        “-blank”, то браузер открывает ссылку в новом окне
                    </P>
                </details>
            </details>
            <details class="chapter5 all">
                <summary>CHAPTER 5</summary>
                <details>
                    <summary class="alltwo">JPEG;PNG;GIF;</summary>
                    <p>Понятие «лучше» обычно определяется как комбинация <em>качества изображения </em>и <em>размера файла</em>. <br>
                        JPEG-фотография чаще  всего намного меньше, чем фото в формате PNG или GIF такого же качества, <br>
                        в то время  как логотип PNG или GIF обычно выглядит  лучше и имеет меньший размер,  <br>
                        чем тот же  логотип в формате JPEG.
                   </p>
                   <p>Если вы размещаете прозрачное изображение на своей веб-странице, то убедитесь, <br>
                       что цвет подложки этого изображения  совпадает с цветом фона. <br>
                        Вы можете использоватьформат PNG или GIF для своего прозрачного изображения.
                   </p>
                </details>
                <details>
                    <summary class="alltwo">IMG&URL</summary>
                    <p>&Lt;img src="http://www.starbuzzcoffee.com/images/corporate/ceo.jpg&GT; </p>
                <p>URL — это путь к рисунку,  поэтому имя файла в конце — всегда имя файла с данным рисунком. <br>
                     Нет такого понятия,  как изображение, используемое  по умолчанию.</p>
                <p>Пример ссылки на само изображение:</p>
                <p>&lt;
                    "a href="html/seattle_downtown.html" <br>
                     "img src="thumbnails/seattle_downtown.jpg"  <br>
                     alt="iPod в бизнес-центре Сиэтла, Вашингтон" "a"&gt;</p>
                <img src="img/img3.jpg" alt="Проводник Head First по лучшим ссылкам" width="980" height="500">
                </details>
            </details>
            <details class="chapter6 all">
                <summary>CHAPTER 6</summary>
                    <details>
                    <summary class="alltwo">Структра HTML</summary>
                    <img src="img/part1 .jpg" alt="Webville-путеводитель по HTML часть1" width="500" height="650" >
                    <img src="img/part2.jpg" alt="Webville-путеводитель по HTML часть2" width="500" height="650">
                    </details>
            </details>
            <details class="chapter7 all">
                <summary>CHAPTER 7</summary>
                <details>
                    <summary class="alltwo">Применению классов CSS</summary>
                    <p>Чтобы добавить комментарий в CSS-код, просто поместите его между символами /* и */</p>
                    <h3 id="adridgement">Краткое руководство по применению классов CSS </h3>
                    <h5>Cуществует ли селектор, соответствующий элементy?</h5>
                    <p>Представьте, что вам нужно узнать значение свойства font-family для элемента. <br> 
                    Первое, что вы  должны проверить: есть ли в вашем CSS-файле селектор для этого элемента. <br>
                    Если он там есть и при этом содержит свойство font-family с конкретным значением, <br>
                    то это значение и будет применяться 
                    для вашего элемента.</p>
                    <h5>Как насчет наследования?</h5>
                    <p>Если для вашего элемента селектора не нашлось, то придется полагаться на наследование. <br>
                    Итак, посмотрите на родительские элементы, их родительские элементы и т. д., <br>
                    пока не найдете определенное в них свойство, которое вам нужно. <br>
                    Если вы его найдете, то это и будет значение данного свойства для вашего элемента.</p>
                    <h5>Снова не нашлось нужное свойства Тогда используйте установленное по умолчанию</h5>
                    <p>Если ваш элемент не наследует значение ни от одного из своих предков, то используется <br>
                    значение свойства,установленное браузером по умолчанию. На самом деле эта схема немного <br>
                    сложнее,чем  мы здесь описали, но подробно мы ее рассмотрим чуть позже.
                    <h5>Сразу несколько эелементов соответствуют этому элементу</h5>
                    <p> &lt;p class="greentea raspberry blueberry" &gt;</p>
                    <p> Итак, побеждает правило с наивысшим приоритетом. </p>
                    <ol>
                    <li> p { color: black;} - Это правило для любого 
                        элемента ‹p›.
                    </li>
                    <li>.greentea { color: green; } - Это правило для любого члена класса greentea. 
                       <br> Оно более приоритетно.</li>
                    <li>p.greentea { color: green; } - Это правило только для абзацев из класса 
                        greentea, <br> поэтому оно еще более приоритетно. </li>
                    <li>p.raspberry { color: blue; } 
                       <br> p.blueberry { color: purple; } <br>Эти правила тоже лишь для абзацев из конкретного 
                       класса. <br> Так что у них с правилом p.greentea одинаковый приоритет.
                    </li>
                    </ol>
                </details>
            </details>
            <details class="chapter8 all">
                <summary>CHAPTER 8(W3C)</summary>
                <h6>W3C-валидатор: http://validator.w3.org</h6>
                <h6>CSS-валидатор вы найдете по адресу:
                http://jigsaw.w3.org/css-validator/</h6>
                <details>
                    <summary class="alltwo">Распространенные форматы (и соответствующие им файловые расширения):</summary>
                    <p>Шрифты TrueType: .ttf - <blockquote>Шрифты TrueType и OpenType тесно связаны между собой;</blockquote></p>
                    <p>Шрифты OpenType: .otf - <blockquote>Формат OpenType основан на TrueType (он новее, чем TrueType).</blockquote></p>
                    <p>Шрифты Embedded OpenType: .otf - <blockquote>Embedded OpenType (EOT) – это компактная форма OpenType. 
                         <br>Данный формат является проприетарным (Microsoft) и поддерживается только браузером Internet Explorer.</blockquote></p>
                    <p>Шрифты SVG: .svg - <blockquote>Scalable Vector Graphics или SVG – это графический формат 
                        общего назначения, используемый в случае со шрифтами SVG 
                        для представления символов.</blockquote></p>
                    <p>Шрифты Web Open Font Format: .wof<blockquote>Web Open Font Format базируется на TrueType и разрабатывается в качестве стандарта для веб-шрифтов. Хорошо поддерживается большинством современных браузеров</blockquote></p>
                </details>
                <details>
                    <summary class="alltwo">Способы задания цвета</summary>
                    <ol>
                        <li>название</li>
                        <li>процентное соотношение(rgb)</li>
                        <li>шестнадцатеричный код(rgb)- #rrggbb<br>
                            (1. 1-9 A-F; 2. c(12)* 16)=192+12=204=rr</li>
                    </ol>
                </details>
            </details>
            <details class="chapter9 all">
                <summary >CHAPTER 9</summary>
                <details>
                    <summary class="alltwo">Блочная модель</summary>
                    <img width="660" height="620" src="img/2023-10-16.png"  alt="Блочная модель">
                    <img width="650" height="620" src="img/2023-10-16 (1).png" alt="Блочная модель">
                    <img width="650" height="620" src="img/2023-10-16 (2).png" alt="Стиль границ">
                    <img width="650" height="620" src="img/2023-10-16 (3).png" alt="Ширина, цвет границы">
                    <img width="650" height="620" src="img/2023-10-16 (4).png" alt="Задание углов границы">
                </details>
                <details>
                    <summar class="alltwo">Медиазапросы</summary>
                    <p>@media screen and (min-device-width: 481px)(если экран равно или меньше); <br>
                       @media screen and (max-device-width: 480px)(если экран больше);<br>
                       @media print { body {font-family: Times, "Times New Roman", serif; }(для распечатки)}</p>
                    <img width="450" height="350" src="img/2023-10-17.png" alt="mediaqueries">
                </details>
            </details>
            <details class="chapter10 all">
                <summary>CHAPTER 10</summary>
                <P>Каскадность</P>
                <ol>
                    <li>Cоберите вместе все таблицы стилей.</li>
                    <li>Найдите все соответствующие объявления свойства.</li>
                    <li>Возьмите все, что нашли, и отсортируйте.</li>
                    <li>Теперь отсортируйте все обьявления по приоритетам.<br> АВТОРСКИЕ, ПОЛЬЗОВАТЕЛЬСКИЕ, БРАУЗЕР;</li>
                    <li>Наконец, отсортируйте все конфликтные правила в том порядке, 
                        <br>в котором они появляются в отдельных таблицах стилей.</li>
                </ol>
                <p> "Какой мой приоритет?"</p>
                <p>0-идектификаторы 0-теги(селекторы) 0-классы</p>
                <img width="650" height="620" src="img/2023-10-17 (1).png" alt="стратегии создания макета">
                <img width="650" height="620" src="img/2023-10-17 (2).png" alt="стратегии создания макета">
            </details>
            <details class="chapter11 all">
                <summary>CHAPTER 11</summary>
                <P>display:table;</P>
                <p>display:table-row;</p>
            </details>
            <details class="chapter12 all">
                <summary>CHAPTER 12</summary>
                <P>"time datetime="2012-02-18">2/18/2012 time" - новый тег</P>
                <p>video</p>
                <img width="650" height="620" src="img/2023-10-17 (3).png" alt="video">
                <img width="650" height="620" src="img/2023-10-17 (4).png" alt="videoformat">
            </details>
            <details class="chapter13 all">
                <summary>CHAPTER 13</summary>
                <img width="650" height="620" src="img/2023-10-17 (6).png" alt="TD">
                <img width="650" height="620" src="img/2023-10-17 (7).png" alt="TH">
                <img width="650" height="620" src="img/2023-10-17 (5).png" alt="css with td th">
            </details>
            <details class="chapter14 all">
                <summary>CHAPTER 14</summary>
                <img width="350" height="320" src="img/2023-10-17 (7).png" alt="">
                <img width="350" height="320" src="img/2023-10-17 (8).png" alt="">
                <img width="350" height="320" src="img/2023-10-17 (9).png" alt="">
                <img width="350" height="320" src="img/2023-10-17 (10).png" alt="">
                <img width="350" height="320" src="img/2023-10-17 (11).png" alt="">
                <img width="350" height="320" src="img/2023-10-17 (12).png" alt="">
                <img width="350" height="320" src="img/2023-10-17 (13).png" alt="">
                <img width="350" height="320" src="img/2023-10-17 (14).png" alt="">
                <img width="350" height="320" src="img/2023-10-17 (15).png" alt="">
            </details>
        </section>
    
        <section class="block_two">
            <details class="all" style="padding-top: 10px;">
                <summary>CSS</summary>
                <h3 id="7chapterproperty">Свойство:</h3>
                <ul>
                    <li> color - для задания цвета текста элемента</li>
                    <li>top - oпределяет позицию верхнего края элемента</li>
                    <li>left - расположить по левому краю</li>
                    <li>padding - отступ  между краем элемента и его содержимым</li>
                    <li>border - рамк вокруг элемента</li>
                    <li>свойство text-indent - красная строка для больших текстов</li>
                    <li>text-align - для выравнивания текста  по левому краю, <br> по центру или по правому краю(используется для выравнивания строчных элементов, применяется родительскому элементу)<li>
                    <li>letter-spacing -  интервал между символами в пределах элемента</li>
                    <li>line-height - межстрочный  интервал в пределах элемент (line-height - font-size = размер между строками)</li>
                    <li>list-style -  контролировать то, как  будут выглядеть пункты списка</li>
                    <li>text-decoration-line: underline | line-through | overline | none;</li>
                    <li>text-decoration-line: solid | double | dotted | dashed | wavy(волнистая линия);</li>
                    <li>Свойство text-decoration-color задает цвет линии у текста. Свойство следует использовать совместно со свойствами text-decoration-line и text-decoration-style.</li>
                </ul>

                <details id="font">
                    <summary>font: курсив жирность размер_шрифта / межстрочный_интервал семейство</summary>
                    <p>font: font-style font-variant font-weight font-size/line-height font-family - <br> порядок-синтаксис для сокращения</p>
                    <ul>
                        <li>font-family - стиль шрифта <br>
                        serif - засечки; sans-serif- без засечек; monospace - фиксированная ширина;<br>cursive - рукописные; fantasy - художественные и декоративные; </li>
                        <li>font-size - делает шрифт больше или меньше</li>
                        <li> font-style - для выделения текста курсивом</li>
                        <li>fonr-weight -задает толщину шрифта <br>
                            (lighter normal bold bolder)<br>
                            Используйте его, чтобы сделать текст полужирным</li>
                    </ul>
                    <p>% - размер шрифта, заданный в процентах, определяет <br>высоту шрифта относительно высоты других шрифтов(родительского);</p>
                    <p>em - размер шрифта, относительная величина. С помощью em вы задаете масштабный коэффициент. <br>(font-size: 1.2em; - означает, что родительский эл. * 1.2 )</p>
                    <p>FontSquirrel (http://www. fontsquirrel.com/)</p>
                </details>
                <details id="textDecoration">
                    <summary>text-decoration</summary>
                    <ul>
                        <li>underline - под</li>
                        <li>overline - над </li>
                        <li>line-through - вычеркивание</li>
                        <li>blink - вокруг</li>
                        <li>none</li>
                    </ul>
                </details>
                <details id="aHref">
                    <summary>a - состояние ссылки(LoVe HAte)</summary>
                    <ul>
                        <li>link - непосещены ссылки</li>
                        <li>visited - посещены </li>
                        <li>hover - навидение мышки</li>
                        <li>active - появиться когдапользоватеь нажмет на него </li>
                        <li>focus - обратить на себя внимание</li>
                    </ul>
                </details>
                <details id="border">
                    <summary>border</summary>
                    <ul>
                        <li>border:solid-сплошная; dotted-точечная; dashed-тире; ridge задает границу в виде выпуклой линии; double - двойная линия; border:толщина цвет тип границы/ в любом порядке</li>
                        <li>
                            border: Если задано два значения, то первое значение задает скругление для для верхнего левого и нижнего правого, второе - верхнего правого и нижнего левого углов</li>
                    </ul>
                </details>
                <details id="background">
                    <summary>background</summary>
                    <p>Порядок свойств значения не имеет. Ненужные свойства можно опускать - в этом случае оно примет значение по умолчанию.</p>
                    <p>Свойства background-position и background-size задаются через слеш и в этом случае порядок имеет значение (сначала позиция, потом размер).</p>
                    <ul>
                        <li>background-color - фоновый цвет </li>
                        <li>background-image -  поместить изображение под элементом</li>
                        <li>background-position: два значения через пробел;Ключевые слова для вертикали: top, center, bottom. Ключевые слова по горизонтали: left, center, right</li>
                        <li>background-size: auto-фон будет иметь натуральный размер, такой, как реальный размер картинки фона; cover-картинка будет стараться поместиться целиком, но это не всегда будет получаться, поэтому какая-то ее часть будет обрезаться. Блок всегда будет покрыт картинкой целиком; contain-блок в общем случае будет покрыт картинкой не целиком (зато картинка всегда будет видна вся, хоть и в уменьшенном варианте)</li>
                        <li>Единицы для размеров и auto могут быть использованы в различных комбинациях, например, так: auto 20px, или 30% 20px, или auto 30% и так далее. В этом случае первый параметр задает размер фона по ширине, а второй параметр - размер фона по высоте. Если указан один параметр - то он будет задавать размер фона и по ширине, и по высоте одновременно</li>
                        <li>Свойство background-attachment задает каким образом прокручивать фоновую картинку элемента: вместе с текстом или текст будет скользить по картинке
                            <ol>
                                <li>fixed	Картинка фона будет неподвижной, а текст будет скользить по ней</li>
                                <li>scroll	Картинка фона будет прокручиваться вместе с текстом.</li>
                                <li>local	Фон фиксируется с учетом поведения элемента. Если элемент имеет прокрутку, то фон будет прокручиваться вместе с содержимым, но фон выходящий за рамки элемента остается на месте</li>
                            </ol>
                        </li>
                        <li>Свойство background-clip задает как фоновая заливка или фоновая картинка будет размещаться относительно элемента
                            <ol>
                                <li>border-box	Фон залезет под границу</li>
                                <li>padding-box	Фон не будет залезать под границу</li>
                                <li>content-box	Фон будет только над содержимым</li>
                            </ol>
                        </li>
                        <li>Свойство background-origin задает то, как фоновая картинка (именно картинка, не заливка) будет размещаться относительно элемента
                            <ol>
                                <li>border-box	Фоновая картинка залезет под границу</li>
                                <li>padding-box	Фоновая картинка не будет залезать под границу</li>
                                <li>content-box	Фоновая картинка будет только над содержимым</li>
                            </ol>
                        </li>
                    </ul>
                </details>
                <details id="float">
                    <summary>float</summary>
                    <p>Плавющий элемент. Выходит из общего потока</p>
                    <p>Получается, что элементы, которым задано свойство float, не расширяют своего родителя по высоте</p>
                    <p>Для решения такой проблемы существует специальное свойство clear, которое отменяет обтекание. Значение left отменяет обтекание слева, значение right - справа, а значение both - с обоих сторон. Это значение и используется чаще всего.
                        <br>При этом clear следует давать тому элементу, на который не должны налазить плавающие элементы, то есть в нашем случае его стоит дать второму диву.</p>
                        <p>Давайте сделаем так, чтобы плавающая картинка расширяла наш див по высоте. Для этого используется хитрый прием - поставим после картинки див без текста с классом clearfix.

                            Наша картинка плавающий элемент и не расширяет родителя по высоте, но див-клиарфикс - не плавающий и влияет на высоту родителя.
                            
                            Так как диву-клиарфиксу задано свойство clear, то получится, что он будет отпихиваться картинкой вниз и стоять под ней, расширяя при этом родителя по высоте.
                            
                            Сам див-клиарфикс пустой и не виден на экране, но при этом расширяет родителя по высоте.</p>

                </details>
                <details id="position">
                    <summary>position</summary>
                    <ul>
                        <p>Если элементу задан relative, а его потомку - absolute, то этот потомок будет позиционироваться относительно своего родителя, а не относительно окна браузера</p>
                        <p>Как правило, в таком случае родителю указывают relative без смещений. В этом случае с этим родителем ничего не происходит, но все его потомки теперь будут позиционироваться относительно него.</p>
                        <p>Может быть и такое, что у родителя задан absolute. В этом случае потомки с absolute также будут позиционироваться относительно такого родителя, а не относительно окна браузера</p>
                        <li>absolute-элемент переместится туда, не взирая на то, что там будут располагаться другие элементы и просто станет поверх их. Говорят, что при этом элемент выпадает из нормального потока документа: все остальные элементы будут вести себя так, будто нашего элемента нет.</li>
                        <li>На самом деле указания координат при абсолютном позиционировании не обязательно. Если элементу просто написать position в значении absolute, то он станет абсолютно спозиционированным, но останется стоять в том же месте, где и стоял. При этом все остальные элементы будут вести себя так, будто нашего элемента нет и могут налезть на него.</li>
                        <li>static-элементы заливаются на 
                            страницу в общем потоке и вы не определяете их месторасположение на странице, — 
                            браузер сам решает, где они отобразятся. 
                            Чтобы убрать элемент из общего потока, 
                            вы можете использовать свойство float. 
                            При этом можно определить, будет элемент 
                            «плавать» слева или справа, но в коненом счете браузер сам решает, где именно 
                            располагать этот элемент
                        </li>
                        <li>fixed-мы разберемся с фиксированным позиционированием. Оно похоже на абсолютное, разница проявляется в том, как ведут себя эти типы позиционирования при наличии полосы прокрутки
                            <p>При прокручивании страницы абсолютно спозиционированные элементы будут прокручиваться вместе со страницей</p>
                            <p> фиксированный блок занял всю ширину экрана, ему нужно задать ширину 100%</p>
                        </li>
                        <li>relative-oтносительное позиционирование задается с помощью значения relative для свойства position. Такое позиционирование позволяет сдвигать элементы относительно своего текущего положения на заданную величину. При этом все остальные элементы страницы будут думать, что элемент стоит там, где и стоял изначально. То есть при таком типе позиционирования элемент не выпадает из нормального потока
                        </li>
                    </ul>
                </details>
                <details id="symbolSelector">
                    <summary>селекторы + знаки</summary>
                    <ul>
                        <li>дочерний селектор > - непосредственный потомок</li>
                        <li>Соседний селектор + позволяет выбрать элемент по его соседу сверху</li>
                        <li>Родственный селектор ~ позволяет выбрать все элементы, находящиеся после заданного элемента внутри одного родителя</li>
                        <li>a[href*="test"] - Селектор атрибута по тексту применяет стиль к элементу, у которого значение атрибута тега содержит определенный текст</li>
                        <li>a[href^="https://"]- start</li>
                        <li>[href$=".html"] - end</li>
                        <li>[class|="text"] - hyphen</li>
                        <li> [class~="test"] cелектор по одному из значений атрибута задает стиль элементу, у которого в атрибуте есть хотя бы одно из указанных значений. При этом все значения атрибута должны быть разделены пробелом</li>
                    </ul>
                </details>
                <details id="inlineBlock">
                    <summary>inline-block</summary>
                    <ul>
                        <li>можно задать ширину и высоту, подобно блочным элементам</li>
                        <li>if у  элемента не задана ширина/высота, то его ширина/высота сформируется содержимым, подобно строчным элементам</li>
                        <li>если расположить несколько элементов рядом, то они выстроятся в ряд</li>
                    </ul>
                </details>
                <details>
                    <summary>margin or padding</summary>
                    <p>Свойство margin применяется не только для задания отступов, но и для центрирования блочных элементов. Для этого правый и левый отступ следует задать в значение auto;</p>
                </details>
                <details id="zIndex">
                    <summary>z-index</summary>
                    <p>Порядок наложения элементов можно регулировать с помощью свойства z-index, принимающего своим значением целые положительные или отрицательные числа, либо ноль. Свойство работает только для элементов, у которых значение position задано как absolute, fixed или relative.</p>
                    <p>При использовании данного свойства правило наложения элементов следующее: выше будет тот элемент, у которого значение z-index больше</p>
                    <p>Если z-index у элемента не задан, то его значение следует трактовать как 0. Это значит, что элемент со значением z-index, равным -1, будет ниже элемента без z-index.</p>
                </details>
                <details id="flex">
                    <summary>flex</summary>
                    <p>Если у флекс элементов не задана ширина, то эта ширина сформируется по содержимому</p>
                    <p>Про флексбоксы можно говорить в двух терминах: первое это - ряд или колонка, второе - в терминах осей. С рядами и колонками мы уже разобрались, давайте теперь разберемся с осями. Понимание осей нужно для того, чтобы выравнивать элементы по горизонтали или по вертикали.

                        При работе с флекс элементами всегда существует главная ось и поперечная. Мы можем элементы выравнивать по главной оси и поперек главной оси. Главная ось может иметь 4 направления: слева направо, справа налево, сверху вниз и снизу вверх.
                        
                        Направление поперечной оси зависит от направления главной: если главная ось горизонтальна, то поперечная направлена сверху вниз, если главная ось вертикальна, то поперечная направлена слева направо. Других направлений поперечная ось иметь не может.</p>
                    <p>Если родителю флекс элементов не задана высота, то по высоте он будет растягиваться своим содержимым, то есть высотой потомков</p>
                    <p>Если родителю флекс элементов не задана ширина, то по ширине он займет все доступное место</p>
                    <p>Вместо значения flex для свойства display родителю можно поставить значение inline-flex. В этом случае этот родитель будет вести себя, как строчно-блочный элемент</p>
                    <ul>
                        <li>Свойство align-items по умолчанию имеет значение stretch. Это значение растягивает элементы на всю ширину вдоль поперечной оси</li>
                    </ul>
                </details>
                <details id="flex-advanced">
                    <summary>Продвинутая работа с флексбоксами</summary>
                    <ul>
                        <li>специальное свойство flex-basis, задает размер элемента вдоль главной оси</li>
                        <li>При желании это пустое пространство можно пропорционально разделить между нашими элементами. Это делается с помощью свойства flex-grow, задаваемого флекс-элементам. Значением этого свойства служит безразмерное число</li>
                    </ul>
                </details>
                <details id="advanced">
                    <summary>Продвинутые свойства для текста на CSS</summary>
                    <ul>
                        <li>Тег pre задает вывод текста в том виде, как он набран в документе: со всеми отступами (табуляцией), пробелами и переносами строк</li>
                        <li>Свойство letter-spacing устанавливает интервал между буквами</li>
                        <li>Свойство word-spacing устанавливает интервал между словами</li>
                        <li>text-transform: capitalize(заглавным первыую букву каждого слово в предложении)/uppercase/lowercase/none</li>
                        <li>Свойство font-variant позволяет сделать маленькие (строчные) буквы ЗАГЛАВНЫМИ, но маленького размера. Такая запись называется капителью: small-caps/none</li>
                        <li>Свойство text-align-last устанавливает выравнивание последней строки текста: по левому краю, по правому, по центру, по левому и правому краям одновременно.<br>Обратите внимание на то, что если в элементе (например, в абзаце), только одна строка - то она считается одновременно первой и последней и выравнивание у нее будет такое, как задано в text-align-last, а не в text-align.</li>
                        <li>Псевдоэлемент first-letter позволяет задать стили первой букве текста в элементе</li>
                        <li>Псевдоэлемент first-line позволяет задать стили первой линии текста</li>
                        <li>Свойство white-space устанавливает как переносить текст на новую строку, а также как отображать пробелы между словами и переносы строк (места, где был нажат Enter при наборе кода)</li>
                        <li>Свойство tab-size устанавливает размер отступа, созданного клавишей Tab.

                            Работает только если задано свойство white-space в значении pre или pre-wrap, а также для тега pre.
                            
                            Значением свойство принимает целое положительно число, которое задает количество пробелов, которому будет соответствовать клавиша Tab. Значение по умолчанию: 8 пробелов</li>
                        <li>Свойство overflow указывает браузеру, как поступать с содержимым (текст, картинки, другие блоки), которое вылазит за границы блока (за его ширину или высоту). Браузер может скрыть вылезающую часть(hidden), добавить полосы прокрутки(scroll/auto) или ничего не делать (visible)(оставить как есть - вылезшим за границы)</li>
                        <li>Свойство text-overflow добавляет троеточие в конец обрезанного текста в знак того, что текст не помещался в блок и был обрезан(ellipsis) или значение по умолчанию(clip).

                            Для работы свойства текст должен быть обрезан через свойство overflow или свойство overflow-x в значении hidden, auto или scroll. Если задано visible (а так и есть по умолчанию) - text-overflow работать не будет.</li>
                            <li>Свойство word-break позволяет перенести буквы длинного слова на новую строку, если это слово не влазит в ширину контейнера</li>
                    </ul>
                    <ul>
                        <li>Свойство columns задает одновременно ширину и количество колонок в многоколоночном тексте. Является свойством-сокращением для column-count и column-width. </li>
                        <li>Свойство column-count задает рекомендуемое количество колонок в многоколоночном тексте. Их реальное количество может отличаться от заданного, в зависимости от ширины колонки и размера промежутка между ними</li>
                        <li>Свойство column-width задает ширину колонок в многоколоночном тексте</li>
                        <li>Свойство column-rule задает границу между колонками в многоколоночном тексте. По принимаемым значениям совпадает со свойством border</li>
                        <li>Свойство column-gap задает расстояние между колонками в многоколоночном тексте, а также расстояние между столбцами в гриде</li>
                        <li>Свойство column-span задает количество столбцов, на которые должен растягиваться элемент в многоколоночном тексте. Свойство значением принимает либо число 1, либо ключевое слово all. При значении 1 элемент будет охватывать одну колонку, а при значении all - все колонки.</li>
                    </ul>
                    <ul>
                        <li>Свойство user-select управляет поведением выделения текста и других элементов на странице</li>
                        <li>Свойство pointer-events позволяет убрать реакцию элемента на события мыши. Свойство принимает два значения. Значение none убирает реакцию, а значение auto заставляет элемент вести себя как обычно (значение по умолчанию)</li>
                        <li>Псевдоэлемент selection позволяет задать цвет и фон выделенному тексту</li>
                    </ul>
                    <ul>
                        <li>Псевдоэлемент after вставляет текст после элемента. Используется только совместно со свойством content, которое задает текст, который следует вставить</li>
                        <li>Псевдоэлемент befor вставляет текст перед элемента. Используется только совместно со свойством content, которое задает текст, который следует вставить</li>
                    </ul>
                </details>
            </details>
            
        </section>
    </div>
    <aside>
        JavaScript
        <details>
            <summary>Цикл</summary>
            <blockquote>while ( пока выражение истинно ) {
                выполняем этот код циклически;
                в начале каждого цикла проверяем выражение в круглых скобках
                }</blockquote>
            <blockquote> Цикл for-of позволяет последовательно перебирать элементы массивов.
                for (let переменнаяДляЭлемента of массив) {
                    /*
                        В переменнуюДляЭлемента по очереди
                        будут попадать элементы перебираемого массива.
                    */}
            </blockquote>
            <blockquote>Для перебора объектов предназначен цикл for-in.
                Можно и ключи, и значения <br>
                <q>for (let key in obj) {
                    console.log(key); // выведет ключ
                }</q>
                <q>for (let key in obj) {
                    console.log(obj[key]); // выведет элементы
                }</q>
            </blockquote>
            <blockquote>for ( начальные команды; условие окончания; команды после прохода ) {
                тело цикла
            }</blockquote>
            <blockquote>Цифры числа при переборе циклом(чтобы обратиться [i], нужно число превратить в строки)</blockquote>
        </details>
        <details>
            <summary>Object</summary>
            <blockquote>К содержимомму ключa объекта можно обратиться через "точечный запись(obj.a)" или "через квадратные скобки (obj["a"], если значение ключа строка, его нужо брать в кавычки)"</blockquote>
            В следующем коде мы из объекта получаем элемент с ключом 'key': <br>console.log(obj['key']) или console.log(obj.key);
            <br> в следующем коде мы из объекта получаем элемент с ключом, имя которого хранится в переменной key:<br>
            console.log(obj[key]);
            <p>При объявлении объекта имена его свойств могут браться из переменных. Такие свойства называются вычисляемыми.</p>
            <p>С помощью оператора in можно проверять наличие свойства в объекте.</p>
            <p>Можно удалять элементы объектов с помощью оператора delete.(delete obj.b(ключ);)</p>
            <p>Изменение объектов через цикл,<br>for (let key in obj) {
                obj[key] = obj[key] * 2;
            }</p>
            <ul>
                <li>Метод Object.keys возвращает массив из свойств объекта в том же порядке, как и при перечислении через цикл.<br>let keys = Object.keys(объект);<br>Также с помощью метода Object.keys можно получить позиции элементов массива</li>
            </ul>
        </details>
        <details>
            <summary>Function</summary>
            <ul>
                <li>функции являются Function Declaration или Function Expression не потому, что имеют имя или не имеют, а потому, что являются участниками выражений или не являются.</li>
                <li>Используйте разницу между Function Declaration или Function Expression: первые могут быть вызваны выше своего определения, а вторые - нет.</li>
                <li>Так как функция выше - это Function Expression и она не присвоена никакой переменной, то ее никак не вызвать, ведь по имени func она будет недоступна.</li>
                <li>Учтите, что выражение, в котором участвует функция, должно быть слева от нее. Если мы что-то пытаемся сделать справа от функции, это не сделает ее функциональным выражением.</li>
                <li>на самом деле функция знает значения внешних переменных, даже не будучи вызванной.</li>
                <li>Когда мы пытаемся обратится к какой-либо переменной внутри функции, эта переменная вначале ищется среди локальных переменных функции и, если такой переменной там нет, то ищется в лексическом окружении функции.</li>
            </ul>
        </details>
        <details>
            <summary>Array</summary>
            <ul>
                <li>Многомерные массивы - вывести - два квадратных скобок</li>
                <li>Метод shift удаляет первый элемент из массива. При этом исходный массив изменяется, а результатом метода возвращается удаленный элемент.<br>массив.shift();</li>
                <li>Метод pop удаляет последний элемент из массива. При этом исходный массив изменяется, а результатом метода возвращается удаленный элемент.<br>массив.pop();</li>
                <li>Метод unshift добавляет неограниченное количество новых элементов в начало массива. При этом исходный массив изменяется, а результатом возвращается новая длина массива.<br>массив.unshift(элемент, элемент, элемент...);</li>
                <li>Метод slice вырезает и возвращает указанную часть массива. Сам массив при этом не изменяется.Он также может принимать отрицательные значения. В этом случае отсчет элемента, на котором закончится обрезание, начинается с конца массива. Последний элемент при этом будет иметь номер -1.<br>массив.slice(откуда отрезать, [докуда отрезать]);</li>
                <li>Метод splice удаляет или добавляет элементы в массив. Можно только удалять элементы, только добавлять или делать и то и другое одновременно. Метод очень универсальный и сложный для понимания. Метод изменяет сам массив и возвращает при этом массив удаленных элементов.<br>массив.splice(откуда удаляем, сколько удаляем, [вставить], [вставить]...);</li>
                <li>Метод find помогает найти первый элемент в массиве согласно переданному в параметре коллбэку. Если элемента нет, то возвращается undefined.</li>
                <li>Метод includes проверяет наличие элемента в массиве. Параметром принимает значение для поиска. Если такой элемент есть в массиве, то метод возвращает true, а если нет, то false.</li>
                <li>Метод map позволяет применить заданную функцию для каждого элемента массива. При этом метод не изменяет исходный массив, а возвращает измененный.
                    Метод в параметре получает функцию, которая выполнится для каждого элемента массива. То, что вернет эта функция через return для элемента массива, станет новым значением этого элемента (см. примеры).
                    В функцию можно передавать 3 параметра. Если эти параметры есть (они не обязательны), то в первый автоматически попадет элемент массива, во второй попадет его номер в массиве (индекс), а в третий - сам массив.<br>let новый массив = массив.map(function(элемент, индекс, массив) {
                        код
                        return измененный элемент;
                    });
                </li>
                <li>Метод forEach позволяет последовательно перебрать все элементы массива. Метод в параметре получает функцию, которая выполнится для каждого элемента массива.
                    В эту функцию можно передавать три параметра. Если эти параметры есть (они не обязательны), то в первый автоматически попадет элемент массива, во второй попадет его номер в массиве (индекс), а в третий - сам массив.<br>массив.forEach(function(элемент, индекс, массив) {
                        код, который выполнится для всех элементов
                    });
                </li>
                <li>Метод filter позволяется отфильтровать элементы массива, оставив только подходящие под определенное условие элементы. Метод в параметре получает функцию, которая выполнится для каждого элемента массива. Своим результатом метод возвращает новый массив, в который войдут только те элементы, для которых переданная функции вернет true.
                    В функцию можно передавать три параметра. Если эти параметры есть (они не обязательны), то в первый автоматически попадет элемент массива, во второй попадет его номер в массиве (индекс), а в третий - сам массив. <br>let новый массив = массив.filter(function(элемент, индекс, массив) {
                        код
                        return true или false
                    });
                    
                </li>
                <li>Метод some проверяет элементы массива в соответствии с переданной функцией. Эта функция передается параметром метода и выполняется для каждого элемента массива. Метод возвращает true, если хотя бы для одного элемента массива переданная функция вернет true, в противном случае метод возвращает false.

                    В функцию можно передавать три параметра. Если эти параметры есть (они не обязательны), то в первый автоматически попадет элемент массива, во второй попадет его номер в массиве (индекс), а в третий - сам массив. <br>массив.some(function(элемент, индекс, массив) {
                        return true или false;
                    });</li>
                <li>Метод every проверяет элементы массива в соответствии с переданной функцией. Метод возвращает true, если для всех элементов массива переданная функция вернет true, в противном случае метод возвращает false.

                    В функцию можно передавать три параметра. Если эти параметры есть (они не обязательны), то в первый автоматически попадет элемент массива, во второй попадет его номер в массиве (индекс), а в третий - сам массив. <br>массив.every(function(элемент, индекс, массив) {
                        return true или false;
                    });
                    </li>
                <li>Метод reduce сворачивает массив к одному значению (редуцирует). К примеру, с помощью этого метода можно легко найти сумму элементов массива (то есть массив сведется к одному значению - к сумме элементов).

                    Первым параметром метод reduce получает функцию, которая последовательно выполнится для каждого элемента массива, начиная с первого. В эту функцию можно передавать 4 параметра. Если эти параметры есть (они не обязательны), то в первый автоматически попадет промежуточный результат, во второй попадет элемент массива, в третий - его номер в массиве (индекс), а в четвертый - сам массив. <br>массив.reduce(function(промежуточный результат, элемент, индекс, массив) {
                        return новый промежуточный результат;
                    }, начальное значение);</li>
                <li>Метод reduceRight работает точно так же как и reduce - смотрите его для полного понимания. Единственное отличие: reduce перебирает элементы слева направо, а reduceRight - справа налево.</li>
            </ul>
        </details>
        <details>
            <summary>Методы</summary>
            <ul class="matem">
                <li>Метод Math.sqrt() возвращает квадратный корень числа</li>
                <li>Math.pow возводит число в заданную степень. <br>
                 Первым параметром передается число, вторым - в какую степень его возвести(внутри скобок).</li>
                <li>Math.sqrt возвращает квадратный корень числа(число внутри скобок).</li>
                <li>Math.round выполняет округление до ближайшего целого числа по 
                    <br>правилам математического округления(число внутри скобок).</li>
                <li>Math.ceil производит округление дробного числа до целого всегда в большую сторону(число внутри скобок).</li>
                <li>Math.floor производит округление числа до целых всегда в меньшую сторону(число внутри скобок).</li>
                <li>toFixed производит округление числа до указанного знака в дробной части<br>
                    число.toFixed([количество знаков в дробной части]); <br>строка.toFixed</li>
                <li>toPrecision округляет число до заданного знака. <br>В отличие от Math.round округление можно проводить не только в дробной части.<br> строка.toPrecision</li>
                <li>Math.max возвращает максимальное число из группы чисел, переданных в функцию.<br> Если в функцию ничего не передано, то будет возращено -Infinity.<br>Math.max(число, число, число...);</li>
                <li>Метод Math.min возвращает минимальное число из группы чисел, переданных параметрами. <br> Если параметрами ничего не передано, то будет возращено Infinity.</li>
                <li> Math.random возвращает случайное дробное число от 0 до 1. Math.random(); <br>function getRandomArbitary(min, max) {return Math.random() * (max - min) + min;} <br> для получения целого цисла <br>function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min;}</li>
                <li>Math.abs возвращает модуль числа, то есть из отрицательного числа делает положительное(число внутри скобок).</li>
            </ul>
            <ul class="registr">
                <li>toUpperCase производит преобразование строки в верхний регистр (из маленьких букв делает большие). При этом возвращается новая строка, а исходная строка не меняется.строка.toUpperCase();</li>
                <li>метод slice можно преобразовать в верхний регистр отдельные буквы.</li>
                <li>toLowerCase - нижний регистр</li>
            </ul>
            <ul class="poiskstroki">
                <li>startsWith проверяет начинается ли строка с указанной в первом параметре подстроки. Если начинается, то возвращает true, а если не начинается, то false. Вторым необязательным параметром метод принимает позицию, с которой начинать проверку (по умолчанию с начала строки).<br>строка.startsWith(что ищем, [начало проверки]);</li>
                <li>endsWith проверяет, заканчивается ли строка на указанную в первом параметре подстроку.<br>строка.endsWith(что ищем, [длина строки]);</li>
                <li>indexOf осуществляет поиск подстроки в строке. В первом параметре указываем искомую подстроку в нужном нам регистре (большие буквы или маленькие). Метод вернет позицию первого совпадения, а если оно не найдено, то вернет -1. <br>строка.indexOf(что ищем, [откуда начинать поиск]);</li>
                <li>lastIndexOf осуществляет поиск последнего вхождения подстроки в строке. При этом необходимо обращать внимание на указанный в первом параметре регистр символов. Поиск ведется с конца строки. Метод вернет позицию первого совпадения с конца, а если оно не найдено, то вернет -1. Вторым необязательным параметром можно передать номер символа, откуда следует начинать поиск.<br>строка.lastIndexOf(что ищем, [откуда начинать поиск]);</li>
            </ul>
            <ul class="massivvstroku i obratno">
                <li>replace осуществляет поиск и замену частей строки. Первым параметром принимается подстрока, которую заменяем, а вторым - подстрока, на которую заменяем.<br>строка.replace(что заменяем, на что заменяем);</li>
                <li>split разбивает строки в массив по указанному в первом параметре разделителю. Если он не задан - вернется вся строка. Если он задан как пустые кавычки, то каждый символ строки попадет в отдельный элемент массива. Вторым необязательным параметром можно указать максимальное количество элементов в получившемся массиве<br>строка.split([разделитель], [максимальное количество элементов]);</li>
                <li>join объединяет элементы массива в строку с указанным разделителем (он будет вставлен между элементами массива). Разделитель задается параметром метода и не является обязательным. Если он не задан - по умолчанию в качестве разделителя возьмется запятая. Если вы хотите слить элементы массива без разделителя - укажите его как пустую строку ''<br>массив.join([разделитель]);</li>
            </ul>
            <ul class="poisk v massive elem i index">
                <li>Метод find помогает найти первый элемент в массиве согласно переданному в параметре коллбэку. Если элемента нет, то возвращается undefined.<br>массив.find(функция);</li>
                <li>Метод findIndex позволяет найти индекс первого элемента согласно согласно переданному в параметре коллбэку. Если элемент не найден, то возвращается -1.<br>массив.findIndex(функция);</li>
                <li>Метод findLast ищет первый элемент с конца массива согласно переданному в параметре коллбэку. Если элемента нет, то в результат возвращается undefined.<br>массив.findLast(функция);</li>
                <li>Метод findLastIndex помогает найти индекс первого элемента с конца массива, соответствующий условию согласно переданному в параметре коллбэку. Если элемента нет, то возвращается undefined.<br>массив.findLastIndex(функция);</li>
            </ul>
            <ul class="redusiya">
                <li>Метод reduce сворачивает массив к одному значению (редуцирует). К примеру, с помощью этого метода можно легко найти сумму элементов массива (то есть массив сведется к одному значению - к сумме элементов).<br>массив.reduce(function(промежуточный результат, элемент, индекс, массив) {
                    return новый промежуточный результат;
                }, начальное значение);</li>
                <li>Метод reduceRight работает точно так же как и reduce - смотрите его для полного понимания. Единственное отличие: reduce перебирает элементы слева направо, а reduceRight - справа налево.<br>массив.reduceRight(function(промежуточный результат, элемент, индекс, массив) {
                    return новый промежуточный результат;
                }, начальное значение);</li>
            </ul>
        </details>
    </aside>
    <aside>
        DOM
        <details>
            <summary>Method</summary>
            <ul>
                <li>querySelector - метод параметром принимает CSS селектор и возвращает ссылку на найденный по этому селектору элемент</li>
                <li>addEventListener - метод, первым параметром принимающий название события (клик на кнопку имеет название 'click'), а вторым параметром - функцию-коллбэк, выполняющуюся при возникновении этого события.<br>события dblclick можно отловить двойной клик по элементу, с помощью события mouseover - наведение курсора на элемент, а с помощью события mouseout - уход курсора с элемента.</li>
                <li>свойство textContent, позволяющее прочитывать текст этих элементов</li>
                <li>свойство innerHTML, позволяющее прочитывать HTML код этих элементов</li>
            </ul>
        </details>
    </aside>
    <aside>
        Vue
        <p>template - верстка</p>
        <p>date - действие</p>
        <p>Во Vue можно создавать свои функции, которые в терминах Vue называются методами. Для этого предназначено свойство methods.</p>
        <details>
            <summary>Директива</summary>
            <ol>
                <li>Вставлять значения свойств из data можно не только в текст, но и в атрибуты тегов. Это делается с помощью директивы v-bind.</li>
                <li> Для того, чтобы навесить событие на какой-нибудь DOM элемент, нужно использовать директиву v-on.<br>
                    В этой директиве после двоеточия нужно указывать имя события, а значением - имя метода, который нужно вызвать по наступлению этого события.</li>
                <li>v-if - c ее помощью можно показывать или скрывать элементы. Как эта директива работает: параметром она принимает любое свойство объекта data. Если это свойство имеет значение true - то элемент будет показан, а если false - то скрыт.</li>
                <li>Можно инвертировать условие с помощью восклицательного знака //p v-if="!visible">text p</li>
                <li>v-model - двусторонняя привязка данных к инпутам в Vue</li>
                <li></li>
            </ol>
        </details>
    </aside>
</body>
</html>